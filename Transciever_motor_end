
// Motor 1 movement x direction - gimbal
// Motor 2 movement y direction - gimbal

#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>

#define led 3
RF24 radio(7, 8); // CE, CSN
const byte addresses[][6] = {"00001", "00002"};

struct Payload {
  int16_t ax;   // angle X
  int16_t ay;   // angle Y
};

bool buttonState = 0;

int lastAx = 0;
int lastAy = 0;

int smoothRead(int pin){
  long sum = 0;
  const int N = 5;
  for (int i =0; i <N; i++){

  sum += analogRead(pin);

  }
  
return sum/N;

}


void setup() {
  pinMode(led, OUTPUT);
  radio.begin();
  radio.openWritingPipe(addresses[1]);    // 00002
  radio.openReadingPipe(1, addresses[0]); // 00001
  radio.setPALevel(RF24_PA_MIN);
}

void loop() {
  delay(5);

  radio.stopListening();

  int potValue_x = smoothRead(A0);
  int potValue_y = smoothRead(A1);

  Payload p;
  p.ax = map(potValue_x, 0, 1023, 0, 180);
  p.ay = map(potValue_y, 0, 1023, 0, 180);

  p.ax = constrain(p.ax, 0, 180);
  p.ay = constrain(p.ay, 0, 180);

  const int DEAD_BAND = 2;
  
  if (abs(p.ax - lastAx) > DEAD_BAND || abs(p.ay - lastAy) > DEAD_BAND) {
    lastAx = p.ax;
    lastAy = p.ay;
    radio.write(&p, sizeof(p));   // send both together ONLY when changed enough
  }


  delay(5);
  radio.startListening();

  unsigned long startTime = millis();
  while (!radio.available()) {
    if (millis() - startTime > 50) { // 50 ms timeout
      return; // skip reading buttonState this loop
    }
  }

  
}

